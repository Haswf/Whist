@startuml
skinparam classAttributeIconSize 0
skinparam linetype polyline
skinparam linetype ortho

class NPC implements IObserver, IPlayer {
    - playerNumber: int
    - hand: Hand
    - info: Hand
    - playerSuits: HashMap<Integer, HashMap<Suit, Boolean>>
    - nest: HashMap<Suit, Boolean>
}

NPC "1" *--> "1" ISelectCardStrategy
NPC "1" --> "1" ITrickModel

interface ISelectCardStrategy {
    + selectCardLead(NPC: npc): Card
    + selectCardFollow(NPC: npc, winningCard: Card, trump: Suit): Card
}

class SmartStrategy implements ISelectCardStrategy{
'    + selectCardLead(NPC: npc): Card
'    + selectCardFollow(NPC: npc, winningCard: Card, trump: Suit): Card
}

class LegalStrategy implements ISelectCardStrategy{
'    + selectCardLead(NPC: npc): Card
'    + selectCardFollow(NPC: npc, winningCard: Card, trump: Suit): Card
}

interface IObserver {
    + update(): void
}

interface IObservable {
    + register(obj: IObserver): void
    + unregister(obj: IObserver): void
    + notifyObservers(): void
}

interface ITrickModel {
    getCards(): Hand
    transfer(selected: Card, playerNum: int): void
    clear(): void
    getRecentCard(): Card
    getRecentCardPlayerNum(): int
}

class TrickModel implements IObservable, ITrickModel{
    - cards: Hand
    - recentCard: Card
    - recentCardPlayerNum: int
    - changed: boolean
}
IObservable --> "*" IObserver

class TrickView implements IObserver {
    + update(): void
    + clear(): void
    + increaseWidth(): void
}

TrickView o-- TrickController
TrickView --> ITrickModel

class TrickController {
   + clear(): void
   + transfer(selected: Card, playerNum: int): void
}

TrickController --> ITrickModel
TrickController --> TrickView

interface IWhistModel{
    + addNPC(npc: NPC): boolean
    + resetNPC(): void
    + dealingOut(): void
    + nextPlayer (): void
    + randomPlayerStartsRound(): void
    + initRound(): void
    + beatCurrentWinner(): void
}

class WhistModel implements IWhistModel{

    - deck: Deck
    - nbPlayers: int
    - nbStartCards: int
    - hands: Hand[]

    + addNPC(npc: NPC): boolean
    + resetNPC(): void
    + deal(): Hand[]
    + dealingOut(): void
    + nextPlayer (): void
    + randomPlayerStartsRound(): void
    + initRound(): void
    + beatCurrentWinner(): void
}

WhistModel --> "*" IPlayer

class WhistVIew {
    + selectCard(): void
    + initialise(): void
    + createLayout(): void
    + createView(): void
    + onGameOVer(winner: int): void
    + showTrump(trumps: Suit): void
    + clearTrump(): void
}

WhistVIew --> IWhistModel

class WhistController{
    + initialise(): void
    + resetNPC(): void
    + createNPC(): void
    + gameOver(winner: int): void
    + playerSelectCard(): Card
    + NPCSelectCardLead(player: int): Card
    + NPCSelectCardFollow(player: int, winningCard: Card, trump: Suit): Card
    + playRound(): Optional<Integer>
}

WhistController --> IWhistModel
WhistController o--	 WhistVIew
WhistVIew --> WhistController
WhistController "1" o-- "1" TrickController
WhistController "1" o-- "1" ScoreBoardController

interface IScoreBoardModel {
    + initialise(): void
    + put(player: int, score: int): void
    + get(player: int): void
    + getScores(): Map<Integer, Integer>
}

class ScoreBoardModel implements IScoreBoardModel, IObservable{
    - scores: Map<Integer, Integer>
    - changed: boolean

    + initialise(): void
    + put(player: int, score: int): void
    + get(player: int): void
    + getScores(): Map<Integer, Integer>
    + register(obj: IObserver): void
    + unregister(obj: IObserver): void
    + notifyObservers(): void
}

class ScoreBoardView implements IObserver{
    - scoreActors: Map<Integer, Actor>

    + createView(): void
    + update(): void
}

ScoreBoardView --> IScoreBoardModel
ScoreBoardView o--	 ScoreBoardController

class ScoreBoardController {
    score(player: int): void
    get(player: int): int
}

ScoreBoardController --> IScoreBoardModel
ScoreBoardController --> ScoreBoardView

class CardUtil{
    + {static} randomCard(hand: Hand): Card
    + {static} randomCard(list: List<Card>): Card
    + {static} rankGreater(card1: Card, card2: Card): boolean
}

class DeckFactory {
    - uniqueInstance: DeckFactory
    + getInstance(): DeckFactory
    + createStandardDeck(): Deck
}

class NFCFactory {
    - uniqueInstance: NFCFactory
    + getInstance(): NFCFactory
    + createLegalNPC(playerNumber: int, trickController: TrickController): NPC
    + createSmartNPC(playerNumber: int, trickController: TrickController): NPC
}

class FontSingleton{
    - uniqueInstance: FontSingleton
    + getInstance(): FontSingleton
}

interface IPlayer {
    selectCardLead(): Card
    selectCardFollow(winningCard: Card, trump: CardUtil.Suit): Card
    setHand(hand: Hand): void
    thinking(): void
    reset(): void
}

class InteractivePlayer implements IPlayer {
    + void setListener(): void
}
@enduml