@startuml
skinparam classAttributeIconSize 0
skinparam linetype polyline
skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam nodesep 50
skinparam ranksep 50
'skinparam linetype polyline
    'skinparam linetype ortho
    skinparam titleBorderRoundCorner 15
    skinparam titleBorderThickness 2
    skinparam titleBorderColor black
    skinparam titleBackgroundColor White
    title <font size = 20>Whist: Static Design Model </font>

header
<font color=red><font size=15>Project Team 30</font>
<font size = 12>Albert Tu (890424), Shuyang Fan (988301), Daniel Coleman (994887)</font>
endheader
class NPC implements IObserver, IPlayer {
    - playerNumber: int
    - hand: Hand
    - info: Hand
    - playerSuits: HashMap<Integer, HashMap<Suit, Boolean>>
    - nest: HashMap<Suit, Boolean>
}

NPC "1" *--> "1" ISelectCardStrategy
NPC "1" --> "1" ITrickModel

interface ISelectCardStrategy {
    + selectCardLead(NPC: npc): Card
    + selectCardFollow(NPC: npc, winningCard: Card, trump: Suit): Card
}

class SmartStrategy implements ISelectCardStrategy{
'    + selectCardLead(NPC: npc): Card
'    + selectCardFollow(NPC: npc, winningCard: Card, trump: Suit): Card
}
class LegalStrategy implements ISelectCardStrategy{
'    + selectCardLead(NPC: npc): Card
'    + selectCardFollow(NPC: npc, winningCard: Card, trump: Suit): Card
}
interface IObserver {
    + update(): void
}

interface IObservable {
    + register(obj: IObserver): void
    + unregister(obj: IObserver): void
    + notifyObservers(): void
}

interface ITrickModel {
    getCards(): Hand
    transfer(selected: Card, playerNum: int): void
    clear(): void
    getRecentCard(): Card
    getRecentCardPlayerNum(): int
}

class TrickModel implements IObservable, ITrickModel{
    - cards: Hand
    - recentCard: Card
    - recentCardPlayerNum: int
    - changed: boolean
}
IObservable --> "*" IObserver

class TrickView implements IObserver {
    + update(): void
    + clear(): void
    + increaseWidth(): void
}

TrickView o-- TrickController
TrickView --> ITrickModel

class TrickController {
   + clear(): void
   + transfer(selected: Card, playerNum: int): void
}

TrickController --> ITrickModel
TrickController --> TrickView

interface IWhistModel{
    addPlayer(player: IPlayer): boolean
    getHands(): Hand[]
    dealingOut(): void
    nextPlayer(): void
    randomPlayerStartsRound(): void
    initRound(): void
    beatCurrentWinner(): void
}

class WhistModel implements IWhistModel{

    - deck: Deck
    - nbPlayers: int
    - nbStartCards: int
    - hands: Hand[]

    + addNPC(npc: NPC): boolean
    + resetNPC(): void
    + deal(): Hand[]
    + dealingOut(): void
    + nextPlayer (): void
    + randomPlayerStartsRound(): void
    + initRound(): void
    + beatCurrentWinner(): void
}

WhistModel --> "*" IPlayer

class WhistView {
    + selectCard(): void
    + initialise(): void
    + createLayout(): void
    + createView(): void
    + onGameOver(winner: int): void
    + showTrump(trumps: Suit): void
    + clearTrump(): void
}

WhistView --> IWhistModel

class WhistController{
    + initialise(): void
    + resetNPC(): void
    + createNPC(): void
    + gameOver(winner: int): void
    + playerSelectCard(): Card
    + NPCSelectCardLead(player: int): Card
    + NPCSelectCardFollow(player: int, winningCard: Card, trump: Suit): Card
    + playRound(): Optional<Integer>
}

WhistController --> IWhistModel
WhistController o--	 WhistView
WhistView --> WhistController
WhistController "1" o-- "1" TrickController
WhistController "1" o-- "1" ScoreBoardController

interface IScoreBoardModel {
    + initialise(): void
    + put(player: int, score: int): void
    + get(player: int): void
    + getScores(): Map<Integer, Integer>
}

class ScoreBoardModel implements IScoreBoardModel, IObservable{
    - scores: Map<Integer, Integer>
    - changed: boolean

    + initialise(): void
    + put(player: int, score: int): void
    + get(player: int): void
    + getScores(): Map<Integer, Integer>
    + register(obj: IObserver): void
    + unregister(obj: IObserver): void
    + notifyObservers(): void
}

class ScoreBoardView implements IObserver{
    - scoreActors: Map<Integer, Actor>

    + createView(): void
    + update(): void
}

ScoreBoardView --> IScoreBoardModel
ScoreBoardView o--	 ScoreBoardController

class ScoreBoardController {
    score(player: int): void
    get(player: int): int
}

ScoreBoardController --> IScoreBoardModel
ScoreBoardController --> ScoreBoardView

class CardUtil{
    + {static} randomCard(hand: Hand): Card
    + {static} randomCard(list: List<Card>): Card
    + {static} rankGreater(card1: Card, card2: Card): boolean
}

class DeckFactory {
    - uniqueInstance: DeckFactory
    + getInstance(): DeckFactory
    + createStandardDeck(): Deck
}

class NPCFactory {
    - uniqueInstance: NPCFactory
    + getInstance(): NPCFactory
    + createLegalNPC(playerNumber: int, trickController: TrickController): NPC
    + createSmartNPC(playerNumber: int, trickController: TrickController): NPC
}

class FontSingleton{
    - uniqueInstance: FontSingleton
    + getInstance(): FontSingleton
}

interface IPlayer {
    selectCardLead(): Card
    selectCardFollow(winningCard: Card, trump: CardUtil.Suit): Card
    setHand(hand: Hand): void
    thinking(): void
    reset(): void
}

class InteractivePlayer implements IPlayer {
    + void setListener(): void
}
@enduml